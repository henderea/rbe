#!/usr/bin/env ruby

Signal.trap('SIGINT') {
  Process.waitall
  puts
  exit 1
}

require 'yaml'
require 'io/console'
require 'shellwords'
require 'thor'
require 'everyday_thor_util'
require 'everyday-plugins'
require 'keychain'
require 'everyday-cli-utils'
include EverydayCliUtils
import :override

EverydayThorUtil::SubCommandTypes.def_types(:command_ids, :flag, :command, :helper)
EverydayThorUtil::SubCommandTypes.def_helper(:helper, :print_info)

module Rbe
  class DataStore
    class << self
      attr_accessor :autosave

      def commands=(commands)
        @commands = commands
        self.save_commands if self.autosave
      end

      def commands
        @commands ||= load_commands
        migrate
      end

      def vars=(vars)
        @vars = vars
        self.save_vars if self.autosave
      end

      def vars
        @vars ||= load_vars
      end

      def temp_vars
        @temp_vars ||= {}
      end

      def command(cmd_id)
        cmd = self.command2(cmd_id)
        if cmd
          cmd[0] ||= cmd[2][:sudo]
          cmd
        else
          nil
        end
      end

      def command2(cmd_id, sc = nil, sl = nil)
        if self.commands.has_key?(cmd_id)
          # [sc || self.commands[cmd_id][:sudo], sl.nil? ? self.commands[cmd_id][:silent] : sl, self.commands[cmd_id]]
          [sc, sl, self.commands[cmd_id]]
        elsif cmd_id.end_with?('_sl')
          command2(cmd_id[0..-4], sc, true)
        elsif cmd_id.end_with?('_nsl')
          command2(cmd_id[0..-5], sc, false)
        elsif cmd_id.end_with?('_s')
          command2(cmd_id[0..-3], 'sudo', sl)
        elsif cmd_id.end_with?('_rs')
          command2(cmd_id[0..-4], 'rvmsudo', sl)
        else
          nil
        end
      end

      def var(var_name)
        if self.temp_vars.has_key?(var_name)
          self.temp_vars[var_name]
        elsif self.vars.has_key?(var_name)
          self.vars[var_name]
        else
          nil
        end
      end

      def migrate
        changed = false
        @commands.each_key { |k|
          sudo = @commands[k][:sudo]
          if sudo.is_a?(TrueClass)
            changed             = true
            @commands[k][:sudo] = 'sudo'
          elsif sudo.is_a?(FalseClass)
            changed             = true
            @commands[k][:sudo] = nil
          end
        }
        save_commands if changed
        @commands
      end

      def load_commands
        @commands = File.exist?(File.expand_path('~/commands.rbe.yaml')) ? YAML::load_file(File.expand_path('~/commands.rbe.yaml')) : {}
      end

      def save_commands
        IO.write(File.expand_path('~/commands.rbe.yaml'), self.commands.to_yaml)
      end

      def load_vars
        @vars = File.exist?(File.expand_path('~/vars.rbe.yaml')) ? YAML::load_file(File.expand_path('~/vars.rbe.yaml')) : {}
      end

      def save_vars
        IO.write(File.expand_path('~/vars.rbe.yaml'), self.vars.to_yaml)
      end
    end
    self.commands.override(:[]=) { |id, dep|
      rv = self.overrides.call_override(:[]=, id, dep)
      self.data_store.save_commands if self.data_store.autosave
      rv
    }
    self.commands.override(:delete) { |id, &block|
      v = self.overrides.delete(id, &block)
      self.data_store.save_commands if self.data_store.autosave
      v
    }
    self.vars.override(:[]=) { |id, dep|
      rv = self.overrides.call_override(:[]=, id, dep)
      self.data_store.save_vars if self.data_store.autosave
      rv
    }
    self.vars.override(:delete) { |id, &block|
      v = self.overrides.delete(id, &block)
      self.data_store.save_vars if self.data_store.autosave
      v
    }

    class << self.commands
      attr_accessor :data_store
    end
    class << self.vars
      attr_accessor :data_store
    end
    self.commands.data_store = self
    self.vars.data_store     = self
    self.autosave            = true
  end
  class DefaultCommands
    extend Plugin

    # register :flag, name: :debug, parent: nil, aliases: %w(-d), type: :boolean, desc: 'print out some debug info'

    register(:command, id: :path, parent: nil, name: 'path', short_desc: 'path', desc: 'print out the path of the current file') { puts __FILE__ }

    register(:helper, name: 'debug?', global: true) {
      if options.has_key?('debug') || options.has_key?(:debug)
        options[:debug]
      else
        d = ENV['debug']
        d == '1' || d == 1 || d == 'true' || d == 't'
      end
    }

    register(:helper, name: 'debug_if', global: true) { |met, &block| print_info(met, &block) if debug? }

    register(:helper, name: 'testpass', global: true) { |pw = nil|
      test = pw.nil? ? `sudo echo "Success" 2>&1`.chomp : `echo "#{pw}" | sudo -S echo "Success" 2>&1`.chomp
      test.include?('Success')
    }

    register(:helper, name: 'getpass', global: true) {
      user = `whoami`.chomp
      begin
        print "Password for user #{user}: "
        pw = STDIN.noecho(&:gets)
        puts
      end until testpass(pw)
      [user, pw]
    }

    register(:command, id: :auth, parent: nil, name: 'auth', short_desc: 'auth', desc: 'authenticate and save password in keychain') {
      user, pw = getpass
      kc       = Keychain.generic_passwords.where(service: 'rbe').first
      if kc.nil?
        Keychain.generic_passwords.create(service: 'rbe', password: pw, account: user)
      else
        kc.password = pw
      end
      puts 'Success!'
    }

    register(:command, id: :test_auth, parent: nil, name: 'test_auth', short_desc: 'test-auth', desc: 'test stored password') {
      kc = Keychain.generic_passwords.where(service: 'rbe').first
      if kc.nil?
        puts 'You need to call `rbe auth` first!'
      else
        pw = kc.password
        puts testpass(pw) ? 'Success!' : 'Failure'
      end
    }

    register(:command, id: :unauth, parent: nil, name: 'unauth', short_desc: 'unauth', desc: 'remove stored password from keychain') {
      kc = Keychain.generic_passwords.where(service: 'rbe').first
      if kc.nil?
        puts 'No stored password!'
      else
        kc.delete
        kc = Keychain.generic_passwords.where(service: 'rbe').first
        puts kc.nil? ? 'Password forgotten' : 'Failure to forget password'
      end
    }

    register(:helper, name: 'array_to_args', global: true) { |arr|
      arr.map { |v|
        v = v.gsub(/{{([\w\d]+)}}/) { |_| DataStore.var($1) }
        (v =~ /^(\||\d?>|<|\$\(|;)/).nil? ? Shellwords.escape(v).gsub(/\\*\+/, '+') : v
      }
    }

    register(:helper, name: 'print_cmd', global: true) { |sudo, cmd, *args|
      arr = array_to_args(args)
      puts "> #{sudo.nil? ? '' : "#{sudo} "}#{cmd} #{arr.join(' ')}"
    }

    register(:helper, name: 'run_cmd', global: true) { |sudo_command, cmd, *args|
      arr = array_to_args(args)
      if sudo_command.nil?
        system("#{cmd} #{arr.join(' ')}")
      else
        kc = Keychain.generic_passwords.where(service: 'rbe').first
        if kc.nil?
          _, pw = getpass
        else
          pw = kc.password
          unless testpass(pw)
            puts 'Stored password invalid!'
            _, pw = getpass
          end
        end
        sudo_command = 'sudo' unless sudo_command == 'rvmsudo' && `which rvmsudo`.chomp.include?('rvmsudo')
        system(testpass ? "#{sudo_command} #{cmd} #{arr.join(' ')}" : "echo '#{pw}' | #{sudo_command} -S #{cmd} #{arr.join(' ')}")
      end
    }

    register(:command, id: :sudo, parent: nil, aliases: %w(s), name: 'sudo', short_desc: 'sudo COMMAND ARGS...', desc: 'run a sudo with the stored password filled in for you') { |*args|
      cmd = args.delete_at(0)
      run_cmd(options[:rvm_sudo] ? 'rvmsudo' : 'sudo', cmd, *args)
    }

    register :flag, name: :rvm_sudo, parent: :sudo, aliases: %w(-r), type: :boolean, desc: 'use rvmsudo instead of sudo'

    register :command, id: :cmd, parent: nil, aliases: %w(command c), name: 'cmd', short_desc: 'cmd SUBCOMMAND ARGS...', desc: 'configure/run stored commands'

    register(:command, id: :cmd_add, parent: :cmd, aliases: %w(reg register), name: 'add', short_desc: 'add cmd_id cmd args...', desc: 'register a command by name') { |cmd_id, cmd, *args|
      if cmd == 'sudo'
        sudo = 'sudo'
        cmd  = args.shift
      elsif cmd == 'rvmsudo'
        sudo = 'rvmsudo'
        cmd  = args.shift
      else
        sudo = nil
      end
      DataStore.commands[cmd_id] = { command: cmd, sudo: sudo, args: args }
    }

    register(:command, id: :cmd_group_add, parent: :cmd, aliases: %w(group_reg group_register), name: 'group_add', short_desc: 'group-add cmd_id cmd...', desc: 'register a command group by name') { |cmd_id, *cmds|
      DataStore.commands[cmd_id] = { command: Array(cmds), sudo: nil, args: nil }
    }

    register(:helper, name: 'print_list', global: true) { |cmd_id, indent = 0, lc = false|
      if lc
        cmds = []
        cmds << cmd_id if DataStore.command2(cmd_id)
      else
        cmds = DataStore.commands.keys
        cmds = cmds.grep(/.*#{cmd_id}.*/) if cmd_id
        cmds.sort!
      end
      if cmds.nil? || cmds.empty?
        puts "#{' ' * indent}Did not find any commands matching #{cmd_id}"
      else
        longest_cmd = lc || cmds.map { |v| v.to_s.length }.max
        cmds.each { |cmd|
          info = DataStore.command2(cmd)
          if info[2][:command].is_a?(Array)
            puts "#{' ' * indent}#{cmd.to_s.ljust(longest_cmd + 2)}=> [\n"
            lc2 = info[2][:command].map { |v| v.to_s.length }.max
            info[2][:command].each { |cmd2| print_list("#{cmd2}#{info[0].nil? ? '' : (info[0] == 'rvmsudo' ? '_rs' : '_s')}#{info[1].nil? ? '' : (info[1] ? '_sl' : '_nsl')}", indent + longest_cmd + 7, lc2) }
            puts "#{' ' * indent}#{' ' * (longest_cmd + 4)} ]"
          else
            puts "#{' ' * indent}#{cmd.to_s.ljust(longest_cmd + 2)}=> #{info[1] ? '(silent) ' : ''}#{info[0].nil? ? '' : "#{info[0]} "}#{info[2][:command]} #{array_to_args(info[2][:args]).join(' ')}"
          end
        }
      end
    }

    register(:command, id: :cmd_list, parent: :cmd, aliases: %w(ls), name: 'list', short_desc: 'list [cmd_id]', desc: 'list registered commands that match argument or all commands if no argument provided') { |cmd_id = nil|
      print_list(cmd_id)
    }

    register(:helper, name: 'extract_args', global: true) { |cmd_id, *args|
      arr   = []
      found = true
      args.each { |v|
        if v.start_with?('+')
          cur_id = v[1..-1]
          found  = cur_id == cmd_id || cur_id.start_with?("#{cmd_id}+")
          arr << cur_id[(cmd_id.length)..-1] if cur_id.start_with?("#{cmd_id}+")
        elsif found
          arr << v
        end
      }
      arr
    }

    register(:helper, name: 'exec_cmd', global: true) { |cmd_id, *extra_args|
      options[:cmd_var].keys.each { |k| DataStore.temp_vars[k.to_s] = options[:cmd_var][k] } if options[:cmd_var]
      cmd = DataStore.command(cmd_id)
      if cmd && cmd[2]
        if cmd[2][:command].is_a?(Array)
          puts "> #{cmd[0].nil? ? '' : "#{cmd[0]} "}rbe cmd group-exec #{cmd_id.to_s} #{array_to_args(extra_args).join(' ')}" unless cmd[1]
          cmd[2][:command].each { |c| exec_cmd("#{c}#{cmd[0].nil? ? '' : (cmd[0] == 'rvmsudo' ? '_rs' : '_s')}#{cmd[1].nil? ? '' : (cmd[1] ? '_sl' : '_nsl')}", *extract_args(c, *extra_args)) }
        else
          print_cmd(cmd[0], cmd[2][:command], *cmd[2][:args], *extra_args) unless cmd[1]
          run_cmd(cmd[0], cmd[2][:command], *cmd[2][:args], *extra_args)
        end
      else
        puts "Could not find command #{cmd_id.to_s}"
      end
    }

    register(:command, id: :cmd_exec, parent: :cmd, aliases: %w(do e group-exec ge), name: 'exec', short_desc: 'exec cmd_id [extra_args...]', desc: 'execute registered command (or command group) that matches argument (append _s to force sudo) (extra_args used normally for single commands, use +cmd_id to specify for a certain cmd, +cmd_grp_id+cmd_id for a subgroup command, and so on)') { |cmd_id, *extra_args|
      exec_cmd(cmd_id, *extra_args)
    }

    register :flag, name: :cmd_var, parent: :cmd_exec, aliases: %w(-v), type: :hash, desc: 'set a temporary variable value'

    register(:command, id: :cmd_remove, parent: :cmd, aliases: %w(rm unreg unregister delete), name: 'remove', short_desc: 'remove cmd_id', desc: 'remove a registered command or command group') { |cmd_id|
      DataStore.commands.delete(cmd_id) if DataStore.commands.has_key?(cmd_id)
    }

    register :command, id: :var, parent: nil, aliases: %w(variable v), name: 'var', short_desc: 'var SUBCOMMAND ARGS...', desc: 'configure stored variables'

    register(:command, id: :var_add, parent: :var, name: 'add', short_desc: 'add VAR_NAME DEFAULT_VALUE', desc: 'add/modify a variable default value') { |name, value|
      DataStore.vars[name] = value
    }

    register(:command, id: :var_list, parent: :var, aliases: %w(ls), name: 'list', short_desc: 'list [var_name]', desc: 'list the variables with defaults, optionally filtering by variable name') { |var_name = nil|
      vars = DataStore.vars.keys
      vars = vars.grep(/.*#{var_name}.*/) if var_name
      vars.sort!
      if vars.nil? || vars.empty?
        puts "Did not find any variables matching #{var_name}"
      else
        longest_var = vars.map { |v| v.to_s.length }.max
        vars.each { |v| puts "#{v.to_s.ljust(longest_var)} => #{DataStore.vars[v].to_s}" }
      end
    }

    register(:command, id: :var_remove, parent: :var, aliases: %w(rm delete), name: 'remove', short_desc: 'remove var_name', desc: 'remove a variable default value') { |var_name|
      DataStore.vars.delete(var_name) if DataStore.vars.has_key(var_name)
    }
  end
end

root_command = Class.new(Thor)
Plugins.get :command, root_command, nil

EverydayThorUtil::SubCommandTypes.add_debugging(root_command, nil, 'debug')

root_command.start(ARGV)